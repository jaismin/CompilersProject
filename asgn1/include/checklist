p_block_statement(p)

reference type

expression_statement explicit constructor invocation

p_statement_expression

array_access uses square brackets

compulsary brackets after for and others

check to handle precedence and dangling else problem

check out statement_no_short_if in case of if else statements has while no short if

check out if then else

pattern matching scala , doubts for switch case

check for the paranthese case

pass and return objects check this out , same goes with declaration

can only pass integers inside the array dimensions

escape the string while making a graph

cast expression as in java only for primitive types


 doubts??
 ternary operators
 for loops in scala
 break
 continue
 do while checkout
 dimensions for a single dimension array
 enum

 line grammer/ 252: int_float,





   # # print p
    # if p:
    #     
    #     print("Syntax error at '%s'" % p.value)
    # else:
    #     print("Syntax error at EOF")
    # print('error: {}'.format(p))
    # print('error: {}'.format(p))
    # while 1:
    #     tok = yacc.token()             # Get the next token
    #     if not tok or tok.type == 'STATE_END':
    #         print tok 
    #         break
    # yacc.restart()
    # Read ahead looking for a terminating ";"
    # print('error: {}'.format(p))
    # while 1:
    #     tok = yacc.token()             # Get the next token
    #     if not tok or tok.type == 'STATE_END' : break
    # yacc.errok()

    # print "Whoa. You are seriously hosed."
    # Read ahead looking for a closing '}'



    For all class names, the first letter should be in Upper Case.

    Method
Names
- All method names should start with a Lower Case letter.

Name of the program file should exactly match the object name.

Scala program processing starts from the main() method, which is a mandatory part of every Scala Program

case class , over ride


var myVar :Int;
val myVal :String;

Allowed


(new Inner).f() // Error: f is not accessible


expressions inside 

for (a <- 0 to max)

for (a <- 0 until max by 2)

0 to -10 by -1


var inc = (x:Int) => x+1

var x = inc(7)-1
It is also possible to define functions with multiple parameters as follows:
var mul = (x: Int, y: Int) => x*y

var factor = 3
val multiplier = (i:Int) => i * factor

override val xc: Int, override val yc: Int